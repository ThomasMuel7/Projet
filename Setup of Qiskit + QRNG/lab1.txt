Quantum Random Number Generation (QRNG) on IBM Quantum Computers
Random numbers are widely used in cryptography, secure key generation, randomized algorithms, and Monte‑Carlo methods. 

In this assignment, you will build a multi‑qubit quantum random number generator (QRNG), run it on IBM Quantum hardware via Qiskit Runtime SamplerV2, and evaluate statistical properties of the output. You will also study transpilation and device topology to understand the hardware factors that influence empirical randomness.

Submission format (choose one):

Option A — PDF of the Jupyter Notebook: Answers written in Markdown and then exported to pdf.

Option B — PDF Report: Plots and discussion in the main body. Add code to the appendix. 

Submit on Canvas.

Collaboration: Work in groups of 1–3 students. All members must actively participate and be prepared to explain any part of the work to the TAs upon request.

Use of generative AI is allowed with disclosure
You may use generative‑AI tools (e.g., ChatGPT, GitHub Copilot, Claude, Gemini, ...) for brainstorming, refactoring, coding assistance, plotting, or editing.

This is allowed with disclosure. Add an AI assistance disclosure as the last section of your submission (or the last cell of the notebook) containing:

Tools/models used (names and versions, if known).

Per‑task usage: for each Task (0–5, and Bonus), a brief note of what the tool was used for (e.g., “Task 3 — suggested code to print final layout; edited and validated by us”).

Prompts/transcripts: main prompts or a summary of interactions (a link or screenshot is acceptable if long).

Validation: how you checked and adapted outputs (tests run, docs consulted, comparisons, plots).

All group members must understand the submitted work and be able to explain it to TAs. Do not paste secrets (API tokens, private data) into third‑party tools.

Learning objectives
Configure qiskit-ibm-runtime and enumerate IBM Quantum backends; extract device topology.

Explain the concept of transpilation (virtual → physical qubits; basis‑gate decomposition; routing; optimization).

Construct a 
-qubit QRNG circuit; transpile to a chosen backend’s ISA; execute on simulator and hardware using SamplerV2.

Apply elementary statistical tests (bias, runs, autocorrelation, inter‑qubit correlation) and interpret results with correct uncertainty quantification.

What to submit 
Submit one file (.ipynb or .pdf). Include:

Device survey table and topology plots (Task 1)

Circuit diagram (Task 2)

Transpilation summary and layout notes (Task 3)

Simulator (exact probabilities + sampled) and hardware histograms (Task 4)

Randomness metrics and brief interpretation (Bonus Task - Not compulsory).

Backend names (A, B)

Code developed
Software requirements 
Python 3.10+

qiskit ≥ 2.1, qiskit-ibm-runtime ≥ 0.40, qiskit-aer ≥ 0.14

IBM Quantum account/API token.

Install (fresh environment recommended):

pip install "qiskit[all]~=2.1" "qiskit-ibm-runtime~=0.40"
References: Official documentation and further reading are listed at the end of this page.

Task 0 — Environment & account
Login into https://quantum.cloud.ibm.com/.Links to an external site. Follow the instructions at Tutorial - IBM Quantum Platform (upgraded): login, API key, and your first run (Bell pair).
Confirm package versions in the notebook output, e.g.:

import qiskit, qiskit_ibm_runtime, qiskit_aer
print(qiskit.__version__, qiskit_ibm_runtime.__version__, qiskit_aer.__version__)
What to include:  a code cell that successfully initializes QiskitRuntimeService and prints versions.

Task 1 — IBM Quantum device survey
Goal: inspect available backends, select two devices (A and B), and record topology/metrics.

Enumerate backends and select:

cands = service.backends(simulator=False, operational=True, min_num_qubits=6)
for b in cands: print(b.name, b.num_qubits)

A = service.least_busy(simulator=False, operational=True, min_num_qubits=6)
B = next(b for b in cands if b.name != A.name)
A, B
Record per device (show code + captured values):

num_qubits, basis (native) gates, and coupling map.

Current queue length (if available) at submission time.

cfgA = A.configuration(); cfgB = B.configuration()
print("A basis_gates:", cfgA.basis_gates)
print("B basis_gates:", cfgB.basis_gates)
cmapA = A.coupling_map; cmapB = B.coupling_map
Visualize topology:

from qiskit.visualization import plot_coupling_map
plot_coupling_map(A.num_qubits, None, cmapA.get_edges())
plot_coupling_map(B.num_qubits, None, cmapB.get_edges())
What to include: a concise table summarizing the above for A and B, plus two topology plots.

 Qubit topology (why it matters):

Topology is the fixed graph of which qubits can directly interact. Your code is free to connect any two logical qubits, but the hardware is not.

When logical neighbors are far apart on this graph, the transpiler must move states (with SWAP‑like sequences) across a path of connected qubits, adding time and error.

Local interference (crosstalk): physically adjacent qubits can influence each other during gates or readout. When you later analyze inter‑qubit correlations (Task 5), check whether unusually correlated pairs are nearby in this graph.

Task 2 — QRNG circuit construction
Goal. Build a k-qubit circuit that produces classical random bits by measuring qubits prepared in an equal‑likelihood state.

How a QRNG makes a classical random bit
Start from a classical 0. In Qiskit, each qubit wire is initialized to the logical 0 state by default.

Apply a coin‑flip instruction. Use a single operation (called the Hadamard, often written "H") that makes the outcomes 0 and 1 equally likely when measured. You do not need to know its matrix form here; only its effect.

Measure to convert the quantum outcome into a classical bit.

Producing many random bits comes from repeating the measurement many times (many shots) and/or applying the same one‑step coin‑flip to many qubits in parallel and measuring them in each shot.

Important note (about “series of Hadamards”): Applying the coin‑flip twice in a row on the same qubit undoes the effect. More coin‑flip operations do not increase randomness; instead, use more shots or more qubits.

How to express this in a quantum circuit (intro level)
Each horizontal wire is a qubit that starts at 0.

Add one coin‑flip instruction to each wire.

Add a measure instruction at the end.

from qiskit import QuantumCircuit

# One‑bit QRNG
qc1 = QuantumCircuit(1)
qc1.h(0)          # coin‑flip on qubit 0
qc1.measure_all() # record the outcome as a classical bit
qc1.draw()

# k‑bit QRNG
def qrng(k: int):
    qc = QuantumCircuit(k)
    for q in range(k):
        qc.h(q)          # one coin‑flip per qubit
    qc.measure_all()
    return qc

k = 6
qc = qrng(k)
qc.draw()
Practical notes. (i) You do not need to declare classical registers explicitly; measure_all() is sufficient for SamplerV2. (ii) In Qiskit’s printed bitstrings, qubit 0 is the rightmost bit; helper functions later will reverse strings so column 0 corresponds to qubit 0.

What to include: the circuit diagram for your chosen k and a brief (2–3 sentences) explanation of the three steps above in your own words.

Task 3 — Transpilation & ISA analysis
High‑level idea: You describe an abstract circuit. Real devices only support a small menu of native operations and let only certain qubit pairs talk directly (the topology). A compiler step called transpilation converts your circuit to what the device can actually do:

It assigns each logical qubit in your code to a physical qubit on the chip (a layout). This is called the layout stage in the Qiskit transpiler.

It rewrites your steps into the device’s supported moves (different but equivalent operations).

If two qubits that need to interact are not directly connected, it inserts special "move" steps (often called SWAPs) to bring their states next to each other along the chip’s connections. More moving → deeper circuits and typically more error. This is called the routing stage in the Qiskit transpiler.

Finally, it tries to optimize and shorten the result.

For this assignment’s QRNG (only single‑qubit coin‑flips + measurements), you should not need two‑qubit interactions; the transpiler will mostly pick a layout (in the layout stage) and express your steps using the backend’s native single‑qubit moves.

Do this:

from qiskit.transpiler.preset_passmanagers import generate_preset_pass_manager

pmA = generate_preset_pass_manager(optimization_level=3, backend=A)
isaA = pmA.run(qc)

pmB = generate_preset_pass_manager(optimization_level=3, backend=B)
isaB = pmB.run(qc)

print("A ops:", isaA.count_ops(), "depth:", isaA.depth())
print("B ops:", isaB.count_ops(), "depth:", isaB.depth())

# (Optional) See which physical qubits were chosen for your logical qubits 0..k-1
print("ISA A initial_index_layout:", isaA.layout.initial_index_layout())
print("ISA A routing_permutation: ", isaA.layout.routing_permutation())
print("ISA A final_index_layout:  ", isaA.layout.final_index_layout())
print("ISA B final_index_layout:  ", isaB.layout.final_index_layout())

# (Optional) Peek at the device’s native gate names (you don't need to know them yet)
print("A basis gates:", A.configuration().basis_gates)
print("B basis gates:", B.configuration().basis_gates)
# Draw the transpiled circuit
isaA.draw()
What to report:

Instruction counts and depth for A and B. Are they similar? (They should be, since the circuit is all single‑qubit.)

Did any two‑qubit operations appear? If yes, explain why you think that happened.

Comment on the chosen layout (which physical qubits your logical 0..k‑1 mapped onto) and whether they are clustered on the chip.

Focus on ISA A. What is the difference of initial_index_layout, routing_permutation, and final_index_layout? Why is routing_permutation an ordered list?
Qiskit Runtime and SamplerV2 
What it is. IBM Quantum Runtime is a managed execution layer that runs your workloads close to the hardware. It exposes high‑level building blocks called primitives. For this assignment you will use:

SamplerV2 — executes circuits and returns samples of measurement outcomes (bitstrings), with a uniform result format on simulators and hardware.

(vs. EstimatorV2 — computes expectation values of observables.)

Why do we use SamplerV2 here? A QRNG needs many measurement shots to obtain bitstrings. SamplerV2:

handles queueing on real devices and shot collection,

applies a consistent schema for results (so plotting/statistics code is the same on the simulator and hardware),

allows optional runtime settings (e.g., error‑mitigation policies) without changing your circuit code.

from qiskit_ibm_runtime import SamplerV2 as Sampler


# Hardware: target a specific backend
sampler = Sampler(mode=A) # or mode=B
result = sampler.run([isaA], shots=4000).result()
counts = result[0].data.meas.get_counts() # {'010011': n, ...}
total = sum(counts.values())
probs = {bitstr: count / total for bitstr, count in counts.items()}

# Simulator with the same result schema
from qiskit.primitives import BackendSamplerV2
from qiskit_aer import AerSimulator
sim_counts = BackendSamplerV2(backend=AerSimulator()).run([isaA], shots=4000).result()[0].data.meas.get_counts()
Notes. (i) You do not need to declare classical registers explicitly; measure_all() is sufficient, and SamplerV2 uses a default register named meas. (ii) Bitstrings are reported in Qiskit’s standard order where qubit 0 is the rightmost bit; our helper functions reverse strings so column 0 corresponds to qubit 0. (iii) You are explicitly transpiling to ISA before calling SamplerV2 in this assignment so you can inspect the mapping; SamplerV2 can also accept higher‑level circuits and compile internally, but we keep that separate for clarity.

Task 4 — Execute (simulator and hardware)
Baseline via simulation:

Sampled counts: Drawing finite samples uses a pseudorandom generator; histograms are unbiased estimators of the exact probabilities but fluctuate with 
 sampling noise.

Implement  sampled counts.

from qiskit.primitives import BackendSamplerV2
from qiskit_aer import AerSimulator

  
# Sampled counts
sim_sampler = BackendSamplerV2(backend=AerSimulator())
sim_counts = sim_sampler.run([isaA], shots=4000).result()[0].data.meas.get_counts()
Note: We run a circuit isaA, which is optimized to run on backend A, on the simulator. This could be good to keep in mind when comparing the simulator with A and B. However, in our case the circuit is simple and there should not be a lot of optimization specific for each backend.

Hardware execution (one or two devices if you can have access easily to the second device):


from qiskit_ibm_runtime import SamplerV2 as Sampler
resultA = Sampler(mode=A).run([isaA], shots=4000).result()
countsA = resultA[0].data.meas.get_counts()
#resultB = Sampler(mode=B).run([isaB], shots=4000).result()
#countsB = resultB[0].data.meas.get_counts()
Plot:

import numpy as np, matplotlib.pyplot as plt

def per_qubit_p1(counts, n):
    shots = sum(counts.values())
    p = np.zeros(n, dtype=float)
    for s, c in counts.items():                 # s like '0101' (qubit 0 is rightmost)
        for j, ch in enumerate(reversed(s)):    # map column 0 -> qubit 0
            if ch == '1':
                p[j] += c
    return p / max(shots, 1)

k = qc.num_qubits  # or isaA.num_qubits
p_sim = per_qubit_p1(sim_counts, k)
p_A   = per_qubit_p1(countsA,    k)

x = np.arange(k); w = 0.42
plt.figure()
plt.bar(x - w/2, p_sim, width=w, label="Aer (sampled)")
plt.bar(x + w/2, p_A,   width=w, label=A.name)
plt.xlabel("Qubit index"); plt.ylabel("Fraction of 1s (P(1))"); plt.title("Per-qubit bias")
plt.xticks(x, [f"q{j}" for j in range(k)]); plt.ylim(0, 1); plt.legend(); plt.tight_layout(); p